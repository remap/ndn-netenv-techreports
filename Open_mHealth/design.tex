\section{Design Requirements}

Fundamentally, NDNFit should follow the Open mHealth paradigm, but adapting its REST-based communication model to a data dissemination approach using NDN. The application must be constructed from an ecosystem with each type of component envisioned by the Open mHealth team, including
1) data capture, 2) secure storage, 3) modeling and analytics, and 4) user
interface components to create a modular, layered sense-making framework. Each component could be provided by  different service providers at different stages in the processing chain, rather than a siloed application.

The design should rely as much as possible on basic NDN primitives (hierarchical naming, interest/data exchange, sync, repositories, keys-as-data, etc.) as possible, rather than designing new protocols.    Given that Open mHealth already envisions a data-centric thin waist in their ecosystem, NDN provides much more relevant functionality at the network layer than IP.   So basic solutions in NDN have much more direct impact on the scalability, security, and ease of development; we need not build up additional layers on IP to get near the app challenges.

The application architecture should be consistent with the discussion above and incorporate reasonable knowledge of the ``cutting-edge'' of  participatory sensing projects (e.g., Mun et al, 2009) and related work in the commercial sector.

The basis for design for all components should include the following: 

\paragraph{Basis for Design}
\begin{itemize}
\item Review of \textbf{NDN research goals and related requirements} as described above. 
\item Review and evaluation of Ohmage reference application and open mHealth schema.
\item Review high level motivation of Estrin \& Sim, 2010 and other references above. 
\item Review case studies, including those on Ohmage website and in the Appendices. 
\item Review past CENS/UCLA participatory sensing research in activity classification,self-surveillance privacy, mobile phone based data collection.
\end{itemize}

\paragraph{Areas of concern} 
NDNFit requires specific design of the following, as an example of the Open mHealth network environment.  
\begin{itemize}
\item Namespace / schema 
\item Repository / storage 
\item Service composability
\item Authentication / identity assurance
\item Data provenance
\item Access auditing
\item Mobile publishing
\item Legal requirements for success
\end{itemize}


\paragraph{Design Goals} 
\begin{itemize}
\item \textbf{Interoperable, Internet-inspired data exchange} as the backbone of the application ecosystem. 
\item \textbf{Thin waist of open data interchange standards} that will enable an ecosystem of sensing, storage, analysis, and user interface components to support medical discovery and evidence-based care 
\item \textbf{User-centric, privacy-aware data exchange} across device, component, and application boundaries
\item Imported from Open mHealth:
    \begin{itemize}
    \item Data-centric rather than service-centric interoperability. $\Rightarrow$ \textbf{Focus on data namespace design.}
    \item Distributed architecture of Capture, DSU, DPU, DVU. $\Rightarrow$ \textbf{Implement data flow approach in NDN.}
    \item End user focus (not hospitals, doctors, etc.) $\Rightarrow$ \textbf{Consumer app deployment scenario.}
    \item User-centric privacy approach. $\Rightarrow$ \textbf{Need to inform user of choices, data flow.}
    \item Encrypted communications. $\Rightarrow$ \textbf{Encryption-based access control, name encryption.}
    \item Mobile publishing. $\Rightarrow$ \textbf{Use as our driver to solve this oft-cited challenge.}
    \end{itemize}
\item In contrast to Open mHealth:
    \begin{itemize}
    \item REST/HTTP is not used.  $\Rightarrow$ \textbf{Move away from RPC call model} and carrying state in Interests, towards data dissemination.
    \item Host-based endpoints for services. $\Rightarrow$ \textbf{Focus on data dissemination model} and NFN style \textbf{distributed processing}. 
    \item OAuth authentication $\Rightarrow$ Need new identity / authentication approach. 
    \item Single storage ``location'' $\Rightarrow$ \textbf{Distributed, ``personal'' repositories}. 
    \end{itemize}
\item \textbf{mHealth Reality Check}. Finally, each component developer should consider the following ``reality check'' questions (and their implicit design goals) for all mHealth applications.\footnote{From the PLOS Medicine Editors. "A reality checkpoint for mobile health: three challenges to overcome." PLoS Medicine 10.2 (2013).}
    %% TODO: Add to cites
    \begin{itemize}
    \item \textbf{Are your systems interoperable?}
    Estrin \& Sim in Science, 2010.  Open mHealth. 
    \item \textbf{Are you using open standards?}
    WHO, 2013.  eHealth unit. 
    \item \textbf{How will you evaluate?}
    Greenhalgh et al. in BMC Med Res. Methodology, 2011.
    Realist and meta-narrative evidence synthesis.
    \end{itemize}

\end{itemize} 

\subsection{Specific Requirements}


%% Repeated from above.
\subsubsection{Naming} 
Our research objective is to see how well basic NDN primitives, such as Interest-Data exchange and Sync, can support the application, proposing new primitives and/or designing new application-level approaches where needed. 
\begin{itemize}
\item \textbf{Namespace design and data payload format should be adapted as directly and consistently as possible from the Open mHealth reference platform and schema library.} 
\item Basic Interest-Data exchange and Sync should be used wherever possible, for example:
\begin{itemize}
\item Consumers should be able to easily access raw and processed data for a certain time period by issuing simple Interests for the appropriate names.
\item Consumers should be able to efficiently read data sequentially, also by issuing simple Interests for the appropriate names. 
\end{itemize}
\item The approach to distributed processing should adapt the Named Function Networking concept for distributed processing (Open mHealth Data Processing Units (DPUs). 
\item Data will include:
    \begin{itemize}
    \item Raw time-location data (GPS, accelerometer) from mobiles. 
    \item Successive rounds of processing that, for example:  
        \begin{itemize}
        \item Generate classified activity data that follows the Physical Activity JSON schema and perhaps other related schemas.  (This happens at client-side in Ohmage Mobility but could happen at a DPU.)	
        \item Identify / segment ``bouts”''of physical activity or exercise. 
        \item Add features to a bout from DPUs to the existing store. 
        \end{itemize}
    \item End-user configuration information
    \item Identity and trust related data
    \end{itemize}
\end{itemize} 




\subsubsection{Trust and security}

Our research objective is to see how well the NDN architectural mechanisms fit into security requirements, and propose new ones where necessary. 
\begin{itemize}
\item Critically, the application's approach to \textbf{identity and trust management} scenario should emerge from the notion of NDNFit as consisting of interoperating components in an ecosystem, not a silo'd application. 
\item All data payloads should be encrypted.  
\item Name encryption should be explored as an advanced feature in this application. 
\item The ecosystem must provide granular access control over various components of the data namespace – in particular, raw location data.  
\item Doing better than Oauth2 for securing distributed processing is important. 
\item Use passive key publication approach (rather than active broker services) if possible, though  tradeoffs between the two solutions should be explored.  
\item If possible, we should support different identities relative each part of the system: collection, processing, and visualization, such as:
    \begin{itemize}
    \item Collection: User may publish data to serve multiple applications, but doesn’t want them to be able to conspire / correlate that they are the same user.
    \item Processing:  Design should provide the minimum possible information to the processing components about user identity. 
    \item Visualization: Visible face of “the app” to the user. 
    \end{itemize}
\end{itemize}

\subsubsection{Storage in the network}

Our research objective is to design one or more repository implementations that support application-specific requirements while preserving as many basic NDN conventions (e.g., versioning, segmenting, etc.) as possible. 

\begin{itemize}
\item NDN-enabled ``repos'' should be used wherever persistent storage is needed in the application, including: 1) storage of sensed data on the mobile capture device; 2) a ``cloud-based'' (or home) personal data repository; 3) temporary storage for processing blocks. 
\item Each user may choose a different storage provider, though we may only have one option in the initial implementation
\item Repos must support encryption-based access control.
\item New legal / economic relationship between the players
\end{itemize}

\subsection{NDNFit Ecosystem components}

First, we introduce the components of the NDNFit application ecosystem, then we discuss overall design strategies for trust, naming, etc. 

The NDNFit user interacts with at least four pieces:
\begin{itemize}
\item Mobile capture application
\item Website for visualization / review
\item Personal data repository service
\item Identity manager (newly envisioned mobile component)
\end{itemize}

\begin{figure}
\begin{center}
\includegraphics[width=.8\textwidth]{figures/NDNFit-App-Architecture-01}
\caption{Draft NDNFit ecosystem design.}
\label{fig:NDNFit-ecosystem}
\end{center}
\end{figure}


%%%%%%%%%%%%%%

\subsubsection{Ohmage-NDN Mobile Activity Capture}

\paragraph{Responsible team members}
Anyang University. UCLA IRL.

\paragraph{Function}
Capture location and activity information, publish. 

\paragraph{Approach}
 
Initially, we will only support Android. Port NFD, tools. Provide NDN-CCL and NFD support for Android. 

Mobile capture application is one of two primary user interfaces.  

Initial analysis of Ohmage mobile client communication completed by Prof. Euihyun Jung's group from Anyang Univ. 

From Basel: Today, we had an internal presentation from the Psychology Dept which explained their use of the Ohmage system that is running in Basel. Although NDNFit comes too late for being applied in ongoing projects, these projects are a good source of insights about user requirements for our future NDNFit system, especially the aspect of data sovereignty.

\paragraph{Building Block: Ohmage \& Mobility}

\url{http://ohmage.org/}
We are going to use the Ohmage Android client (including the Mobility module) with only the in-app storage and communication changed to NDN. See (Tangmunarunkit, H., et al., 2014) and also the papers on the Ohmage website. Note that Mobility generates activity classified data that may not require the Activity Classification DPU in the initial version.

ohmage is an open-source participatory sensing technology platform. It supports: 1) expressive project authoring; 2) mobile phone-based data capture through both inquiry-based surveys and automated data capture as well as temporally and/or spatially triggered reminders, 3) data visualization and real-time feedback; privacy respecting data management; and 4) extensible data exploration. 

Tangmunarunkit, H., et al. "Ohmage: A General and Extensible End-to-End Participatory Sensing Platform,” ACM Trans. on Intelligent Systems and Technology (in submission), UCLA CS Technical Report 140015. (Used in 20 projects.)  \url{http://web.ohmage.org/~hongsudt/pub/ohmage_ucla_140015.pdf}

%%%%%%%%%%%%%%

\subsubsection{Personal Data Repository}

\paragraph{Responsible team members}
Design led by Jianxun in Dan Pei’s group at Tsinghua.

\paragraph{Function}

Provide Open mHealth Data Storage Unit (DSU) functionality.  (Also, ``personal data vault''.) 
Personal in that it is controlled by the end user.  NOT necessarily a home repository.  More realistically, a storage service with fiduciary responsibility to protect the data of the end-user per Kang et al. 

\paragraph{Approach}

One or more new NDN repo designs supporting a hierarchy of storage needs: mobile device, user private repository, temporary processing storage.
Storage at:
\begin{itemize}
\item The mobile device itself.
\item A personal data repository (which may be distributed).
\item Temporary storage for processing and visualization components. 
\end{itemize}

Current plan:  implement in Java using jNDN, for Android support.  

\paragraph{Reference: Open mHealth Data Storage Unit (DSU) Design}

\url{https://github.com/openmhealth/developer/wiki/DSU-Overview}

The Open mHealth DSU (Data Storage Unit) API Specification is an open specification for unified information sharing across disparate data streams. The idea is simple: create an easy-to-understand set of APIs that allow siloed data stores to share information. Third-party applications that understand this API specification can then create a single set of tools to access data across any of the servers.

\paragraph{Building Block: Personal Data Vault}
Reference Derek's work here? 

Mun, Min, et al. "Personal data vaults: a locus of control for personal data streams." Proceedings of the 6th International Conference. ACM, 2010.http://remap.ucla.edu/jburke/publications/Mun-et-al-2010-Personal-Data-Vaults.pdf

Kang, J., Shilton, K., Estrin, D., Burke, J. "Self-surveillance privacy." Iowa L. Rev. 97 (2011): 809.http://escholarship.org/uc/item/1jk8b2q1.pdf


%%%%%%%%%%%%%%

\subsubsection{Distributed Processing Blocks}

\paragraph{Responsible team members}
Basel

\paragraph{Function}
Goal here is to have a few representative components implemented using NFN-style approach, not exactly the processing blocks listed above, necessarily.   Start with GeoFencing, as activity classification is currently handled in the Mobility portion of Ohmage.  But, could also consider other application-specific processing ideas. 

Initially, focusing on location-based triggers (geofencing) - to trigger location-based content.

\paragraph{Approach}

Ideally, provide composable data flow inspired by Google Cloud Dataflow, Apache Spark, etc.  

Web-based front end using NDN-JS with access to geofenced location information, providing location-specific content back to the mobile user.

Related to vehicular networking work. 

\paragraph{Reference: Open mHealth Data Processing Unit (DPU) Design}

\url{https://github.com/openmhealth/developer/wiki/Open-mHealth-and-Data-Processing}

DPUs are stateless modules that input and output data. They are designed to be embedded in other software or called remotely. They do not produce anything directly visible, but are the brains and muscles of an application. The concept of a DPU is inspired by the Unix Philosophy of creating small functional tools that can be chained and reused, rather than a single large application.

\paragraph{Building Block: Named Function Networking }

\url{http://www.named-function.net/}

Names serve to access and invoke functions, which incidentally can produce passive content once it is needed. New questions arise from this point of view, namely how the network organizes the flow of functions, which brings us squarely into active networking turf. 

\paragraph{Content Source: Trails Database}

\url{http://archinect.com/news/article/111897927/tour-los-angeles-history-with-ucla-s-new-interactive-urban-trail-app}

The LASHP Trails Mobile Website gives residents and visitors to Northeast Downtown Los Angeles site-specific access to a dynamic combination of historic information and health-related activities along urban trails starting and ending at the Los Angeles State Historic Park. 

%%%%%%%%%%%%%%

\subsubsection{Visualization Interface}

\paragraph{Responsible team members}
UCLA REMAP

\paragraph{Function}
Provide basic visualization of fitness data.

\paragraph{Approach}
Start with Ohmage web front end
NDN-JS and D3
Web-based front end using NDN-JS with access to geofenced location information, providing (for example) running trail visualization.
Perhaps use many GPX format visualizers.  E.g., \url{http://flowingdata.com/2014/02/05/where-people-run/}

\paragraph{Reference: Lifestreams Dashboard}
\cite{hsieh2013acm}

\paragraph{Building Block: Analytics / Presentation: Ohmage Front-end for Mobilize}

\url{https://wiki.mobilizingcs.org/app/web}

And Lifestreams?
Web-based front end using NDN-JS to access derived data without location information.
Examples: http://quantifiedself.com/fitbit/   

The web frontend (powered by the ohmage project) is used to provide students secure access to their data. It supports secure login, campaign management, data management and basic campaign monitoring and visualization. The students can review and share their data to the growing data set collected by their class. The web frontend can also be used to discover the answers to basic statistical inferences in real-time as data is being collected. When data collection is complete, the web frontend allows for easy exporting of the data to a more thorough statistical analysis tool. 



%%%%%%%%%%%%%%

\subsubsection{Identity Manager}
    
\paragraph{Responsible team members}
UCLA IRL (Yingdi)? and REMAP (Dustin)?
  
%%%%%%%%%%%%%%%%%%%
  
  \section{Design of NDNFit} 
\subsection{Naming}

\paragraph{Responsible team members}
UCLA REMAP, UCLA IRL


\subsubsection{Data}
Personal health data (and metadata) namespace and repository design is focusing on support for physical activity data in the first round.  
What schema? 

\textbf{Basis of design}: Open mHealth Physical Activity data schema\footnote{\url{http://www.openmhealth.org/developers/schemas/#physical-activity} and \url{http://bioportal.bioontology.org/ontologies/SNOMEDCT?p=classes&conceptid=68130003}}, as well as other schemas from Open mHealth as needed. 

\input{physical-activity-schema-json}

The proposed data namespace is shown in Figure~\ref{fig:NDNFit-namespace}. Its components are discussed briefly here (The black part is what we have reached agreement on, and the gray part is what needs more discussions and feedbacks):

\begin{itemize}
\item Trust anchor

The root \url{/org/openmhealth} is the trust anchor of NDNFit, users, DSUs, DPUs get identities and certificates from the trust anchor. 

\item DPU and DVU

NDNFit-provided DPU and DVU have identities of the format \url{/org/openmhealth/<service-id>}, they get identities and certificates from the trust anchor. Notice that non-NDNFit-provided DPU and DVU can have identities of other format, such as \url{/edu/ucla/cs/irl/speed-caculator}, \url{/edu/ucla/remap/distance-caculator} and so on.

\item User's data

Each user has an service-independent identity \url{/org/openmhealth/<user-id>}. All the user's data are named after this prefix. This prefix may not be necessarily routable, though it	could be. Users get identities and certificates from the trust anchor.

A user can possess multiple mobile devices, to differentiate them, the user can further assign identity \url{/org/openmhealth/<user-id>/<device-id>} and issue certificate to each of them.

\begin{itemize}
	\item Data - data branch
	
	The original Data has 3 levels of types. In the example (so the first implementation), they are \url{fitness}(first level), \url{physical_activity}(second level) and \url{time_location}(third level). Under \url{time_location node}, there are 3 branches. The leftmost branch stands for captured data. Each data packet can have multiple samples (time location points) in it, in which case the timestamp component in its name is the start timestamp of all the samples. The middle branch is catalog. Catalogs are generated every 10 minutes (or other more appropriate time interval), the timestamp components in their names must be \url{YYYY-MM-DDTHH:MM:00Z}. Each catalog data packet contains all the names of captured data whose timestamp falls into the time span (this catalog's timestamp ~ next catalog's timestamp). The rightmost branch is C-KEY which is used for data access control, we will discuss this in data access control section.
	
	The DPU-processed data are published in the bout branch. Similar to the original data branch, the leftmost branch stands for processed data, the middle branch stands for catalog, and the rightmost branch is C-KEY.
	
	\item Data access control - read branch
	
	Name-based access control is used here. Take captured data as an example to illustrate how it works here in NDNFit.
	
	Every hour, a new C-KEY (symmetric content encryption key) is generated and used to encrypt all the captured data in this hour. The C-KEY is encrypted by the E-KEY of each access group who has access to the corresponding captured data, and is named \url{/<prefix>/C-KEY/<start_timestamp_hour>/<end_timestamp_hour>/FOR/<E-KEY name>}. The \url{start_timestamp_hour} and \url{end_timestamp_hour} are the start and end hour points when the C-KEY is valid. For each access group, the E-KEY and D-KEY (asymmetric key pair) are also generated periodically (the period is not fixed to 1 hour). The E-KEY is named
	\url{/<prefix>/E-KEY/<start_timestamp_hour>/<end_timestamp_hour>/}; and the D-KEY is encrypted for each member (data consumer) of this access group and named \url{/<prefix>/D-KEY/<start_timestamp_hour>/<end_timestamp_hour>/FOR/<consumer-public-key-name>}. Notice that in this case, all the C-KEYs, E-KEYs and D-KEYs are generated by the user.
	
	For the DPU-processed data (the bout branch), it's a little complicated. In this case, the C-KEY should be generated by the DPU, and then it should be sent back to the user (the C-KEY should be encrypted only for the user) to be encrypted by some access groups? E-KEYs. All the other steps are the same as the previous.
	
	\item Data publish control - write branch
	
	When a DPU processes user's data, it should use some valid signing key to sign the processed results. The signing key pair is generated by the DPU, the private key is kept by the DPU and the public key is sent back to the user. Then the user checks whether the public key is named properly (so data consumers can validate the signature of processed results according to trust schema), if it is, the user can sign and publish this public key. The name structure of this public key is similar to that of D-KEYs.
	

\end{itemize}
\item User group
	
Some users can form groups. Groups have identities of the format \url{/org/openmhealth/<group-id>}. This is not part of first implementation. Details will be discussed in the future.

\end{itemize}


\begin{figure}
\begin{center}
\includegraphics[width=1.0\textwidth]{figures/NDNFit-name-top-02.png}
\caption{NDNFit Namespace, version 2.}
\label{fig:NDNFit-namespace}
\end{center}
\end{figure}

%%%%%%%%%%%%%%
  
\subsection{Trust and security}

\paragraph{Responsible team members}
U. Michigan, UCLA IRL, UCLA REMAP

\subsubsection{Trust model} 

In this application, the user should be the root of trust for their own data, though this may be enabled
by various service providers. 

If possible, we would like to leverage the existing PKI/SPKI support in NDN, and take advantage of the
existing infrastructure.  \emph{However}, certificates used should not leak real world identity 
information except by the choice of the user. 

One entity (here, the `` user") maintains multiple publishers whose data are
consumed by many services with varying levels of access based on the: type
of data (as expressed in the name), level of granularity, and date/time
when the data was produced. 

However, users only possess mobile devices. So a proper design should guarantee users can use mobile devices to sign data correctly so that consumers can validate data, and to encrypt data flexibly so that only specified consumers can get access to the data. That's why trust relationship and access control are extremely important in NDNFit.

We will talk about trust relationship management and data-centric access control mechanism in this section.

\subsubsection{Schematized Trust\cite{yingdi:schematizing}}
In NDN, the trust relationship is used for data signing and signature validation, which are reverse process of each other. Data packets are signed by some identity using its \verb|data signing key|, and its \verb|data signing key| is further signed by another identity using its \verb|key signing key|. This \verb|key signing key| is further signed by another identity using its \verb|key signing key|... This process ends when a authorized trust anchor is reached. To make this process reliable, the data signing and signature validation must follow some strict trust rule. 

\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{./figures/trustrelationship3.png}
	\caption{Trust Relationship for Capture Application}
	\label{fig:trustrelationship}
\end{figure}

Figure \ref{fig:trustrelationship} shows the trust relationship for signing originally captured data and validating these data's signature. A user's data should be signed by the NDNFit application running on his/her mobile device, which is further signed by this mobile device, and further signed by his/her user ID, and finally signed by the NDNFit trust root.

This trust relationship works for all users, but it's complicated for users to configure the similar trust relationship individually. So NDNFit itself can adopt schematized trust mechanism to configure a single rule for all the users using human-readable config files. The same solution will work for the default trust relationship of DSUs, DPUs and DVUs.

A more complicated case is that DPUs and DVUs will process users' raw data and produce data that should belong to the users, and these data should be put back to users' DSUs. In this case, users can sign DPUs'/DVUs' data signing keys to add them into their trust relationship, authorizing DPUs/DVUs to sign data under users' namespace. This trust relationship can be much more easily expressed by using schematized trust.


SHOW THE EXAMPLE AFTER WE REACH AGREEMENT

\subsubsection{Name-Based Access Control\cite{yingdi:nbac}}\label{nbac} 

NDN team proposes a data-centric access control mechanism -- name-based access control, which enabls producers to fully control their data in fine granulariy. Figure \ref{fig:nbac} shows the basic idea of name-based access control. In name-based access control, data are divided into some minimum access units. For example, the data of the same type and the same hour belong to the same access unit. For each minimum access unit, a symmetric encryption key is generated and used by the data producer to encrypt all the data falling into this unit. There are also different levels of access control groups, each covers a different access scope -- a different subset of all the minimum access units. Every access control group has a group manager (multiple groups can have the same group manager), whose signing key pair is signed by the data producer. The group manager is responsible for generating and updating group asymmetric encryption and decryption key pair, and using encryption keys to encrypt symmetric encryption keys of minimum access units covered by the group's access scope.

\begin{figure}
	\centering
	\includegraphics[width=0.3\textwidth]{./figures/nbac2.png}
	\caption{Name-based Access Control Mechanism}
	\label{fig:nbac}
\end{figure}

If a consumer wants to get access to some parts of a producers' data, the consumer should first tell the producer what data it wants, then the producer will join it into a proper existing group or create a new group for this consumer. To join a consumer into a group, the producer needs to use the consumer's public signing key to encrypt the group's decryption keys. 

After a consumer is authorized to get access to some data, it should follow the following steps to decrypt data. First, it fetches the encrypted group decryption keys and use its own private signing key to decrypt them. Second, it uses these decryption keys to decrypt the symmetric encryption keys for the corresponding minimum access units. Lastly, it uses these symmetric encryption keys to decrypt the corresponding original data.

Here we describe how name-based access control is used in NDNFit. 

1. Every access control group can be represented by a name prefix \url{/<user-prefix>/read/<data-prefix>}, all the asymmetric key pairs belonging to this group should be named after this prefix. \url{/org/openmhealth/haitao/read/physical_activity/time_location} means that this is an access control group which has the scope of everyday haitao's time\_location data.

2. In NDNFit, a user should control all its data, so instead of delegating group management authority to other identities, the user's identity (e.g. \url{/org/openmhealth/haitao}) is the manager of all the access control group. 

3. An access control group is represented by a prefix of the format \url{/org/openmhealth/<user-id>/read/<mutiple data types>} The name of an encryption key belonging to an access control group is of the format \url{/<access-control-group-prefix>/E-KEY/<start_timestamp>/<end-timestamp>}. This key is not encrypted, so anyone can get access to it. 
Similarly, the name of an decryption key for an access control group is of the format \url{/<access-control-group-prefix>/D-KEY/<start_timestamp>/<end-timestamp>}. The decryption key is encrypted for consumers who have read access using the consumer's public signing key, so that only the exact consumer can decrypt it using its private signing key, the name is of the encrypted decryption key is of the format \url{/<access-control-group-prefix>/D-KEY/<start_timestamp>/<end-timestamp>/FOR/<consumer's public key name>}. An example is \url{/org/openmhealth/haitao/read/physical_activity/time_location/D-KEY/20151020113000/20151020123000/FOR/org/openmhealth/alice/E-KEY}, this is a decryption key for the user \url{alice}.

4. The data of the same type and the same hour belong to the same minimum access unit, and the name of its symmetric encryption key is of the format \url{/org/openmhealth/<user ID>/<data type 1>/<data type 2>/<data type 3>/C-KEY/<hourpoint>}. This key is encrypted for different access control group, and the names are of format \url{/org/openmhealth/<user ID>/<data type 1>/<data type 2> /<data type 3>/C-KEY/<hourpoint>/FOR/<access-control-group-prefix>}. For example, \url{/org/openmhealth/haitao/data/physical_activity/time_location/C-KEY/2015102010/FOR/org/openmhealth/haitao/read/physical_activity}.

By adopting name-based access control mechanism, users can easily use mobile devices to generate all the mentioned keys. These keys can be stored in DSUs just like ordinary data, since only consumers who has right keys can decrypt these keys. 
Consumers should follow steps described before to get access to a producer's data.

\subsubsection{Request and Grant Read \& Write Access}

FILL THIS PART AFTER WE REACH AGREEMENT

\subsubsection{Identity}

% Commenting out the old text for identity

% Users may have different identities per service (or at least per flow). 

% We are exploring the idea of an ``identity manager", an application
% manages the certificates (identities) that an individual uses to interact
% with the various services involved in this application. Are there good
% examples of \emph{user interfaces} for identity management already?  In fact,
% pointers to state-of-the-art in end-user interfaces for security decision
% making would be helpful. Alex doesn't think there are many. 

% Each step in the data processing model tends to generate derived data that must also be stored and 
% may or may not be associated with the original identity.  

Three types of identities are involved in the NDNFit application. A user identity, which associates with a user of applications in the Open mHealth ecosystem; a device identity, which associates with a device that the user owns; and an application identity, which associates with an application installed on a device.

User and device identity generation are handled by a separate application called ``identity manager'' (ID manager). In the case of NDNFit, to generate a user identity, the ID manager first asks the Open mHealth authority for a namespace under which its data can be published, then generates a key for that namespace, and asks the Open mHealth root of trust to sign that key and provide a certificate. The interaction between ID manager and Open mHealth root of trust goes through email and http requests: that is, the Open mHealth authority will associate an assigned namespace with a user that owns the email address he provided. Device identity is generated by the identity manager, and signed by the user identity. User identities may be used to sign device identities for each device that the user owns, but the first iteration of the design does not cover this interaction.

An application identity is generated upon the first launch of the application. The application asks the ID manager on the same device for the data publishing namespace, and generates a key for that data namespace. This key is signed by the device identity, and is used to sign the data produced by the application.

For a user's data to be verified, application certificates, device certificates, and user certificates need to be published.

An example of the trust relationship is given in Figure \ref{fig:identity}.

\begin{figure}
\begin{center}
\includegraphics[width=0.75\textwidth]{figures/NDNFit-identity-example}
\caption{User, device, and app identity for NDNFit application}
\label{fig:identity}
\end{center}
\end{figure}

\subsubsection{Integrity} 

\subsubsection{Confidentiality}

Principal of minimum information:  services should only request / consume the minimum 
amount of information needed to complete their application. 

We will need to come up with an approach for name encryption for
this environment, in a way that still enables applications to operate on
the namespace--perhaps without having to be concerned with
decryption--once it has been decrypted and/or de-encapsulated.

Public access should be considered but is primarily for future access. 
Extensions to support epidemiological studies incorporating semi-anonymized opt-in data across large populations. 


\subsubsection{Data flow model support}

Must consider access control for services 
in "data flow" model for communication between processing components, replacing Oauth. 

We imagine a data flow like model for this system:
[Publisher]->[Processing]->[Processing]->[Visualization], with each []
block being owned by a different entity and an objective to leak the
minimum amount of context to the processing components.  I'm not sure we
understand how to handle authentication /  access control of the
intermediate processing blocks, to each other and to the source/sink of
the data.  Where can we look for best practices for security in current
data flow architectures?

%%%%%%%%%%%%%%


\subsection{Capture}
Based on the previous analysis, Prof. Euihyun Jung's group and UCLA IRL have built a running NDNFit Android data capture application. 

This application captures time-location data,  produces Data and temporarily stored these Data locally. When the mobile device (re)connects network, the NDNFit Android application will automatically send the choosed DSU its current routable prefix using LINK and notify the DSU that it is online. On receiving notification, the DSU will fectch data from the NDNFit Android application using the data fetching protocols we decribe above. After confirming that the DSU have successfully fetched all the data, the NDNFit Android application will delete local stored data.

 Figure~\ref{fig:NDNFit-UI} shows the UI of NDNFit data capture application. To use it, users only need to click ``Start Tracking'' and ``Stop Tracking'', all the other steps will be completed automatically by the application.

\begin{figure}
	\begin{center}
		\includegraphics[width=0.4\textwidth]{figures/NDNFit.png}
		\caption{NDNFit Application UI}
		\label{fig:NDNFit-UI}
	\end{center}
\end{figure}
%%%%%%%%%%%%%%
  
\subsection{Storage}

\paragraph{Responsible team members}
UCLA IRL, Tsinghua, UCLA REMAP

A distributed network of repos replaces the ecosystem of DSUs envisioned in the Open mHealth TCP/IP architecture. 

(Hierarchical network of repositories, similar to BAS/BMS, including both personal repositories, service provider backups for personal data, and aggregated "anonymized" stores). 

Need to provide write access control

A mechanism for delegating authority to publish into a repository is
necessary. 


%%%%%%%%%%%%%%

\subsection{Processing}
Borrow ideas from Named Function Networking concept for distributed processing

%%%%%%%%%%%%%%%
  
\subsection{Routing \& Forwarding: Use ``LINK object'' to help route}

\paragraph{Responsible team members}
UCLA IRL

Mobile publishing support. NDNS?

Using provider-independent namespace leads to the problem that packets cannot be routed and forwarded correctly by the NDN routing system. 

To solve this problem, we need to apply a mechanism called \verb|link|\cite{alex:snamp}. By creating a \verb|link|, data producers or data cache servers can map the provider-independent name prefixes to one or more routable prefixes of their ISPs (for example, map \verb|/org /openmhealth /haitao| to \verb|/edu /ucla /cs /irl|). Then they save the \verb|link| to the NDNS\cite{afanasyev2013addressing}. After looking up \verb|links| from NDNS, consumers put these \verb|links| into their \verb|Interest| packts; then NDN routing system use the mapping information provided by \verb|links| to route the packets to the right destination.
Notice that in mobile case, data producers need to update and put their \verb|links| into NDNS in time so that data consumers are able to get the current efficient ones.

Two different kinds of \verb|links| should be used in NDNFit.
\subsubsection{Public Link}
The public \verb|link| is the same as the original \verb|link|. We call it public because every consumer can get access to and use this kind of \verb|link|. Every components except for mobile devices will create public \verb|links| and put them into NDNS.
\subsubsection{Private Link}
The private \verb|link| is created by mobile devices and used by DSUs to fetch data form them. The reason to make them private is that mobile devices are always power limited, leading to the result that they cannot work stably as data servers. The better choice is, after mobile devices capture data, DSUs fetch data from them as soon as possible and work as providers for these data. Thus, mobile devices only need to provide data to DSUs. So mobile devices need to create private \verb|links| that only can be seen by DSUs. 

We design two ways to make a \verb|link| private. The first is that the mobile device encrypts it and puts it into NDNS, but only gives some DSUs the decryption key (this is achieved by data-centric access control). The second  is the mobile device sends \verb|Interest| to DSUs to notify them to fetch \verb|link| (it's also encrypted) when needed.

\begin{figure}
\centering
\subfigure[Mobile publisher connected to ``home'' hub, which directly routes its publishing prefix.]{
\includegraphics[width=0.45\columnwidth, keepaspectratio=true]{figures/publisher-mobility-a}
}
\subfigure[Mobile publisher connected to another hub, which does not directly route its prefix.]{
\includegraphics[width=0.45\columnwidth, keepaspectratio=true]{figures/publisher-mobility-b}
}
\caption{Mobile publisher scenario.}
\label{fig:mobilepublisher}
\end{figure}

\subsection{Data Transmission Protocols}
In NDNFit, DSUs work as the center of data flow. There should be three different data  transmission cases in NDNFit. (1) DSUs fetch data from other components,  (2) other components fetch data from DSUs, and (3) data sync between DSUs. We use DSUs fetch data from mobile devices and DPUs fetch data from DSUs as examples to illustrate the first two. 

\subsubsection{DSUs Fetch  Data from Mobile Devices}\label{synctoDSU}
There are three problems need to be solved. (a) Mobile device are not always online, so DSUs should know when to fetch data. (b) Mobile capture data are named with a random timestamp component, DSUs should know the exact names before fetching data. (c) Mobile devices have limited resource such as storage and power, so they should know when to delete locally stored data.

To solve the first problem, a mobile device needs to send signal \verb|Interest| to a DSU whenever it reconnects the Internet, then the DSU can start to fetch data from the mobile device. When the DSU cannot get response from the mobile device for more than a certain time limit, such as 10 minutes, it should treat the mobile device as off-line.

We introduce one level of direction - catalog - used by DSUs to learn the names of captured data from mobile devices. A mobile device packages captured data names into a catalog every 10 minutes. That is to say, a catalog contains the names of data captured in the past 10 minutes. The first figure in Figure \ref{fig:catalog} shows the packet format of catalogs. The names for catalogs should follow the format \verb|/org/openmhealth/<user ID>/data/physical_actirvity/time_location/catalog/<timestamp>|. Following the naming convention of catalogs, DSUs can construct catalog names and fetch catalog back.

To confirm that a DSU have fetched all the data whose names are packaged in the same catalog, a mobile device sends a confirmation request \verb|Interest| right after it sends out the catalog. After the DSU gets all these data, it will send confirmation \verb|Data| back to the mobile device. Once the mobile device receives the confirmation, it can delete the corresponding local stored data.
The names of confirmations should follow the format \verb|/<DSU prefix>/confirm/<catalog name>|.

After receiving signal \verb|Interest| from a mobile device, a DSU sends \verb|Interest|s to fetch catalog starting from the last non-responded timepoint, get responses and unpack the captured data names; shortly, the DSU receives \verb|Interest|s for confirmations from the mobile device. Then the DSU sends \verb|Interest|s for captured data and fetches data back. When successfully fetching all the data whose names are packed in a same catalog, the DSU responds the mobile device's \verb|Interest| for confirmation to this catalog.

\begin{figure}
	\centering
	\includegraphics[width=0.7\textwidth]{./figures/catalog.png}
	\caption{The Manifest and Update Info Packets}
	\label{fig:catalog}
\end{figure}

\subsubsection{DPUs Fetch Data from DSUs}\label{syncfromDSU}
The catalog  mechanism explained in section \ref{synctoDSU} is also introduced and used by DPUs to fetch the names of stored data from DSUs; while the confirmation mechanism is omitted since DSUs never delete data. 

However, a new problem emerges. When a user has multiple mobile devices to capture data and some of them temporarily do not have network connection, the mobile devices which have network connection will put their data into DSUs first, triggering DSUs to generate catalogs; when the mobile devices which do not have network connection reconnect network and put the same type of data into DSUs, DSUs need to update some of the previous catalogs (whose timestamp covers the timestamp of the new data). Without updating catalogs, DPUs cannot get the latest data.

To solve this problem, a new component ``version'' is added to the tail of catalogs names. Newly received ``out date'' data will trigger DSUs to generate new catalogs with higher visions. Table \ref{tbl:threedatanames} shows the name format of catalog. To get the latest versioned catalogs, DPUs should set the ``ChildSelector'' field of \verb|Interest| packets to be ``RightMostChild'' and ``MustBeFresh'' field of \verb|Interest| packets to be ``True''.

However, the problem is not fully solved. DPUs which have not fetched the old versioned catalogs can set the ``ChildSelector'' and ``MustBeFresh'' to get the latest version. The ones which have fetched the old versioned catalogs and cached them, so they cannot get the latest version unless they never cache data. But cache mechanism can greatly improve system performance, so we still want to allow DPUs to cache data.

That's why the update information mechanism, which is used for DPUs to fetch update information of catalogs, is introduced. The second  figure in Figure \ref{fig:catalog} shows the packet format of update information, and Table \ref{tbl:threedatanames} shows the name format of update information. The sequence number of update information starts from 1. Whenever some catalogs which have the same \verb|n-3| (\verb|n| is the number of components in the catalog) prefixes with the update information are updated, a new update information with a bigger sequence number, which packages all the updated catalogs' names and the corresponding latest versions together, will be generated.

Combine catalog and update information mechanisms together, DPUs can always get the latest versioned catalogs, thus the latest data. To achieve that, DPUs first fetch the latest update information by sending an \verb|Interest| with  ``ChildSelector'' field  to be ``RightMostChild'' and  ``MustBeFresh'' field to be ``True''. Second, DPUs fetch all the latest versioned catalogs by sending \verb|Interest|s according to naming convention. Last, DPUs keep requesting the next sequenced update information; if get it, DPUs fetch the latest versioned catalogs whose names are packaged in this update information; then DPUs continue to keep requesting the next sequenced update information.

\begin{table*}
	\centering
	\caption{Three Types of Names in Sync Protocols}
	\renewcommand{\arraystretch}{1.5}
	\begin{tabular}{|c|c|c|} \hline
		Type & Name pattern & Example \\ \hline
		Original data &
		\parbox[c]{0.4\textwidth}{\url{/org/mhealth/<user-id>/<data-type1>/<data-type2>/<data-type3>/<timestamp>}}
		& \parbox[c]{0.4\textwidth}{\url{/org/mhealth/haitao/data/physical_activity/time_location/20150702180347}}\\ \hline
		Catalog & \parbox[c]{0.4\textwidth}{\url{/org/mhealth/<user-id>/<data-type1>/<data-type2>/<data-type3>/catalog/<timestamp>/<version>}}& \parbox[c]{0.4\textwidth}{\url{/org/mhealth/haitao/physical_activity/time_location/catalog/201507021800/2}}\\ \hline
		Update Info & \parbox[c]{0.4\textwidth}{\url{/org/mhealth/<user-id>/<data-type1>/<data-type2>/<data-type3>/update_info/<sequence #>}}
		& \parbox[c]{0.4\textwidth}{\url{/org/mhealth/haitao/physical_activity/time_location/update_info/73}}\\ \hline
	\end{tabular}
	\label{tbl:threedatanames}
\end{table*}


\subsubsection{Data Sync between DSUs}
NDNFit allows a user to choose multiple DSUs to work as his/her DSUs, each of them keeps a same copy of all the user's data. This mechanism backups the user's data in case that a single DSU crushes or fails. Keeping the same copy of data means that DSUs need to sync database with each other.

Existing repo sync protocol\cite{shireposync} fits this scenario well. Notice that only data fetched from other components are synchronized, catalogs and update information generated by DSUs should not be synchronized. That's because we want each DSU to generate the same catalogs and update information for itself instead of assigning a master DSU to do so, in the latter case the system still suffers from single node failure problem.

